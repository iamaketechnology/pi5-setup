#!/usr/bin/env bash
set -euo pipefail

# === FIX REMAINING ISSUES - Corriger les derniers probl√®mes Supabase ===

TARGET_USER="${SUDO_USER:-$USER}"
[[ "$TARGET_USER" == "root" ]] && HOME_DIR="/root" || HOME_DIR="/home/$TARGET_USER"
PROJECT_DIR="$HOME_DIR/stacks/supabase"

log()  { echo -e "\033[1;36m[FIX-FINAL]\033[0m $*"; }
warn() { echo -e "\033[1;33m[WARN]\033[0m $*"; }
ok()   { echo -e "\033[1;32m[OK]\033[0m  $*"; }
error() { echo -e "\033[1;31m[ERROR]\033[0m $*"; }

require_root() {
  if [[ "$EUID" -ne 0 ]]; then
    echo "Ex√©cute : sudo ./fix-remaining-issues.sh"
    exit 1
  fi
}

install_netcat() {
  log "üì¶ Installation netcat pour tests de connectivit√©..."

  if command -v nc >/dev/null; then
    ok "‚úÖ netcat d√©j√† install√©"
  else
    log "   Installation netcat-openbsd..."
    apt update -qq
    apt install -y netcat-openbsd
    ok "‚úÖ netcat install√©"
  fi
}

check_project_directory() {
  if [[ ! -d "$PROJECT_DIR" ]]; then
    error "‚ùå Projet Supabase non trouv√© dans : $PROJECT_DIR"
    exit 1
  fi

  cd "$PROJECT_DIR"
  log "üìç Travail dans : $PROJECT_DIR"
}

cleanup_yaml_errors() {
  log "üßπ Nettoyage erreurs YAML pr√©existantes..."

  if [[ ! -f "docker-compose.yml" ]]; then
    error "‚ùå docker-compose.yml manquant"
    exit 1
  fi

  # Backup avant nettoyage
  cp docker-compose.yml "docker-compose.yml.backup.cleanup.$(date +%Y%m%d_%H%M%S)"

  # Supprimer RLIMIT_NOFILE mal plac√© (dans volumes au lieu d'environment)
  if grep -q "RLIMIT_NOFILE:" docker-compose.yml; then
    warn "‚ö†Ô∏è RLIMIT_NOFILE mal plac√© d√©tect√© - correction..."
    sed -i '/^[[:space:]]*RLIMIT_NOFILE:/d' docker-compose.yml
    ok "‚úÖ RLIMIT_NOFILE mal plac√© supprim√©"
  fi

  # Valider YAML apr√®s nettoyage
  if docker compose config >/dev/null 2>&1; then
    ok "‚úÖ docker-compose.yml valide apr√®s nettoyage"
  else
    error "‚ùå docker-compose.yml encore invalide"
    log "üìã Erreurs YAML :"
    docker compose config 2>&1 | head -3
    exit 1
  fi
}

check_system_entropy() {
  local entropy=$(cat /proc/sys/kernel/random/entropy_avail 2>/dev/null || echo "0")

  if [[ $entropy -lt 1000 ]]; then
    warn "‚ö†Ô∏è Entropie syst√®me faible ($entropy) - peut causer blocages"
    log "   üí° Installer haveged : sudo apt install haveged"
    return 1
  fi

  return 0
}

create_auth_schema() {
  log "üóÑÔ∏è Cr√©ation schema auth PostgreSQL..."

  # V√©rifier entropie syst√®me avant d'essayer
  check_system_entropy

  # Obtenir l'ID du conteneur directement pour √©viter docker compose exec
  local container_id=$(docker compose ps -q db 2>/dev/null || true)

  if [[ -z "$container_id" ]]; then
    error "‚ùå Conteneur PostgreSQL non trouv√©"
    return 1
  fi

  # Test de connectivit√© avec timeout
  log "   Test connectivit√© PostgreSQL..."
  if ! timeout 10 docker exec "$container_id" pg_isready -U postgres >/dev/null 2>&1; then
    warn "‚ö†Ô∏è PostgreSQL pas pr√™t - attente 15s suppl√©mentaires..."
    sleep 15
    if ! timeout 10 docker exec "$container_id" pg_isready -U postgres >/dev/null 2>&1; then
      error "‚ùå PostgreSQL inaccessible apr√®s 25s"
      return 1
    fi
  fi

  # V√©rifier si schema auth existe avec docker exec direct
  log "   V√©rification schema auth existant..."
  if timeout 10 docker exec "$container_id" psql -U postgres -t -c "SELECT 1 FROM information_schema.schemata WHERE schema_name = 'auth';" 2>/dev/null | grep -q "1"; then
    ok "‚úÖ Schema auth existe d√©j√†"
    return 0
  fi

  # Cr√©er schema auth et extensions avec docker exec direct
  log "   Cr√©ation schema auth et extensions..."

  local auth_sql="
CREATE SCHEMA IF NOT EXISTS auth;
CREATE EXTENSION IF NOT EXISTS pgcrypto;
CREATE EXTENSION IF NOT EXISTS \"uuid-ossp\";
GRANT USAGE ON SCHEMA auth TO postgres;
"

  # Utiliser docker exec avec timeout au lieu de docker compose exec
  if timeout 15 bash -c "echo '$auth_sql' | docker exec -i '$container_id' psql -U postgres" >/dev/null 2>&1; then
    ok "‚úÖ Schema auth cr√©√© avec succ√®s"
    return 0
  else
    error "‚ùå √âchec cr√©ation schema auth"
    log "   üí° Essaye avec reset-and-fix.sh pour r√©initialisation compl√®te"
    return 1
  fi
}

diagnose_restarting_services() {
  log "üîç Diagnostic des services qui red√©marrent..."

  # Utiliser timeout pour √©viter blocages
  local restarting_services
  if ! restarting_services=$(timeout 10 docker compose ps --format "{{.Name}} {{.Status}}" 2>/dev/null | grep -i "restarting" | awk '{print $1}' || true); then
    warn "‚ö†Ô∏è Impossible d'obtenir le statut des services"
    return 1
  fi

  if [[ -n "$restarting_services" ]]; then
    warn "‚ö†Ô∏è Services en red√©marrage :"
    echo "$restarting_services" | while read -r service_name; do
      if [[ -n "$service_name" ]]; then
        service_short=$(echo "$service_name" | sed 's/supabase-//')
        log "   üîç $service_short - Derni√®res erreurs :"
        timeout 5 docker compose logs "$service_short" --tail=3 2>/dev/null | sed 's/^/      /' || echo "      Logs non disponibles (timeout)"
      fi
    done
    echo ""
    return 1
  else
    ok "‚úÖ Aucun service en red√©marrage"
    return 0
  fi
}

fix_auth_service() {
  log "üîß Correction service Auth..."

  # V√©rifier si Auth red√©marre
  if docker compose ps auth | grep -q "Restarting"; then
    log "   Auth red√©marre - V√©rification variables..."

    # Test si API_EXTERNAL_URL est visible dans le conteneur
    if docker compose exec -T auth printenv | grep -q "API_EXTERNAL_URL" 2>/dev/null; then
      ok "   ‚úÖ API_EXTERNAL_URL pr√©sente"
    else
      warn "   ‚ùå API_EXTERNAL_URL manquante - Correction..."

      # V√©rifier qu'elle est dans .env
      if grep -q "^API_EXTERNAL_URL=" .env; then
        log "   Variable pr√©sente dans .env - Recreation conteneur..."
        docker compose stop auth
        docker compose rm -f auth
        docker compose up -d auth
      else
        error "   API_EXTERNAL_URL manquante dans .env"
        return 1
      fi
    fi
  else
    ok "   ‚úÖ Auth ne red√©marre pas"
  fi
}

fix_storage_service() {
  log "üîß Correction service Storage..."

  if docker compose ps storage | grep -q "Restarting"; then
    log "   Storage red√©marre - Test authentification DB..."

    # Tester connexion supabase_storage_admin
    if docker compose exec -T db psql -U supabase_storage_admin -d postgres -c "SELECT 1;" >/dev/null 2>&1; then
      ok "   ‚úÖ Utilisateur supabase_storage_admin fonctionne"
    else
      warn "   ‚ùå Probl√®me auth supabase_storage_admin - Correction..."

      # Recr√©er utilisateur
      local storage_password=$(grep "^SUPABASE_STORAGE_PASSWORD=" .env | cut -d'=' -f2)
      if [[ -n "$storage_password" ]]; then
        docker compose exec -T db psql -U supabase_admin -d postgres -c "
          DROP USER IF EXISTS supabase_storage_admin;
          CREATE USER supabase_storage_admin WITH ENCRYPTED PASSWORD '$storage_password';
          GRANT USAGE ON SCHEMA public TO supabase_storage_admin;
          GRANT ALL PRIVILEGES ON ALL TABLES IN SCHEMA public TO supabase_storage_admin;
          GRANT ALL PRIVILEGES ON ALL SEQUENCES IN SCHEMA public TO supabase_storage_admin;
          GRANT ALL PRIVILEGES ON ALL FUNCTIONS IN SCHEMA public TO supabase_storage_admin;
        " >/dev/null 2>&1

        log "   Red√©marrage Storage..."
        docker compose restart storage
        ok "   ‚úÖ Storage corrig√©"
      else
        error "   SUPABASE_STORAGE_PASSWORD manquant dans .env"
      fi
    fi
  else
    ok "   ‚úÖ Storage ne red√©marre pas"
  fi
}

fix_realtime_service() {
  log "üîß Correction service Realtime..."

  if docker compose ps realtime | grep -q "Restarting"; then
    log "   Realtime red√©marre - Probl√®me RLIMIT_NOFILE..."

    # V√©rifier la variable probl√©matique dans les logs
    if docker compose logs realtime --tail=5 | grep -q "RLIMIT_NOFILE: unbound variable"; then
      warn "   ‚ùå Variable RLIMIT_NOFILE non d√©finie"

      log "   Correction du docker-compose.yml..."

      # Ajouter variable RLIMIT_NOFILE au service realtime
      if ! grep -A20 "realtime:" docker-compose.yml | grep -q "RLIMIT_NOFILE"; then
        # Backup du fichier
        cp docker-compose.yml docker-compose.yml.backup.realtime.$(date +%Y%m%d_%H%M%S)

        # M√©thode simple et fiable pour ajouter RLIMIT_NOFILE
        log "   Correction RLIMIT_NOFILE dans realtime environment..."

        # D'abord supprimer toute ligne RLIMIT_NOFILE mal plac√©e
        sed -i '/^[[:space:]]*RLIMIT_NOFILE:/d' docker-compose.yml

        # Puis ajouter RLIMIT_NOFILE dans la section environment de realtime
        if grep -A5 -B5 "realtime:" docker-compose.yml | grep -q "environment:"; then
          # Si environment existe, ajouter RLIMIT_NOFILE apr√®s la premi√®re ligne environment
          sed -i '/realtime:/,/^[[:space:]]*[a-z-]*:/ {
            /environment:/,/^[[:space:]]*[a-z-]*:/ {
              /environment:/ {
                a\      RLIMIT_NOFILE: 65536
              }
            }
          }' docker-compose.yml
        else
          # Si environment n'existe pas, l'ajouter apr√®s restart
          sed -i '/realtime:/,/^[[:space:]]*[a-z-]*:/ {
            /restart:/ {
              a\    environment:
              a\      RLIMIT_NOFILE: 65536
            }
          }' docker-compose.yml
        fi

        log "   Red√©marrage Realtime..."
        docker compose stop realtime
        docker compose up -d realtime
        ok "   ‚úÖ Realtime corrig√©"
      fi
    else
      log "   Autre probl√®me d√©tect√©..."
      docker compose restart realtime
    fi
  else
    ok "   ‚úÖ Realtime ne red√©marre pas"
  fi
}

fix_edge_functions_service() {
  log "üîß Correction service Edge Functions..."

  if docker compose ps edge-functions | grep -q "Restarting"; then
    log "   Edge Functions red√©marre - Diagnostic..."

    local edge_logs=$(docker compose logs edge-functions --tail=5)
    if echo "$edge_logs" | grep -q "Print help"; then
      warn "   ‚ùå Edge Functions affiche l'aide au lieu de d√©marrer"
      log "   Probl√®me de configuration - Recreation..."

      docker compose stop edge-functions
      docker compose up -d edge-functions
      ok "   ‚úÖ Edge Functions relanc√©"
    else
      log "   Autre erreur d√©tect√©e..."
      docker compose restart edge-functions
    fi
  else
    ok "   ‚úÖ Edge Functions ne red√©marre pas"
  fi
}

test_all_connectivity() {
  log "üß™ Tests de connectivit√© complets..."

  local tests_passed=0
  local tests_total=5

  # Test Studio
  if curl -s -I "http://localhost:3000" >/dev/null 2>&1; then
    ok "  ‚úÖ Studio accessible (localhost:3000)"
    ((tests_passed++))
  else
    warn "  ‚ùå Studio non accessible"
  fi

  # Test API Gateway
  if curl -s -I "http://localhost:8001" >/dev/null 2>&1; then
    ok "  ‚úÖ API Gateway accessible (localhost:8001)"
    ((tests_passed++))
  else
    warn "  ‚ùå API Gateway non accessible"
  fi

  # Test PostgreSQL avec nc
  if nc -z localhost 5432 2>/dev/null; then
    ok "  ‚úÖ PostgreSQL accessible (localhost:5432)"
    ((tests_passed++))
  else
    warn "  ‚ùå PostgreSQL non accessible via nc"
  fi

  # Test PostgreSQL direct
  if docker compose exec -T db psql -U supabase_admin -d postgres -c "SELECT version();" >/dev/null 2>&1; then
    ok "  ‚úÖ PostgreSQL fonctionne (connexion directe)"
    ((tests_passed++))
  else
    warn "  ‚ùå PostgreSQL connexion directe √©choue"
  fi

  # Test Edge Functions
  if curl -s -I "http://localhost:54321" >/dev/null 2>&1; then
    ok "  ‚úÖ Edge Functions accessible (localhost:54321)"
    ((tests_passed++))
  else
    warn "  ‚ùå Edge Functions non accessible"
  fi

  log "Tests r√©ussis: $tests_passed/$tests_total"

  if [[ $tests_passed -ge 4 ]]; then
    ok "‚úÖ Connectivit√© excellente"
    return 0
  elif [[ $tests_passed -ge 2 ]]; then
    warn "‚ö†Ô∏è Connectivit√© partielle"
    return 1
  else
    error "‚ùå Connectivit√© probl√©matique"
    return 2
  fi
}

wait_for_stabilization() {
  log "‚è≥ Attente stabilisation des services (30s)..."

  for i in {30..1}; do
    if [[ $((i % 10)) -eq 0 ]]; then
      echo -n "   ‚è≥ $i secondes... "
      # Test rapide
      local restarting_count=$(docker compose ps | grep -c "Restarting" || true)
      if [[ $restarting_count -eq 0 ]]; then
        echo "(Tous services stables)"
        break
      else
        echo "($restarting_count services red√©marrent encore)"
      fi
    fi
    sleep 1
  done
}

show_final_status() {
  echo ""
  echo "==================== üìä √âTAT FINAL ===================="

  docker compose ps --format "table {{.Name}}\t{{.Status}}" | head -11

  echo ""
  echo "üß™ **Tests de connectivit√©** :"
  test_all_connectivity

  echo ""
  if diagnose_restarting_services; then
    echo "üéâ **SUPABASE COMPL√àTEMENT FONCTIONNEL !**"
    echo ""
    echo "üìç **Acc√®s aux services** :"
    local ip=$(hostname -I | awk '{print $1}')
    echo "   üé® Studio : http://$ip:3000"
    echo "   üîå API : http://$ip:8001"
    echo "   ‚ö° Edge Functions : http://$ip:54321"
    echo ""
    echo "‚úÖ **Tous les probl√®mes r√©solus !**"
  else
    echo "‚ö†Ô∏è **Quelques services peuvent encore se stabiliser**"
    echo "   Attendre 2-3 minutes suppl√©mentaires"
  fi
  echo "=================================================="
}

main() {
  require_root

  log "üîß Correction des derniers probl√®mes Supabase Pi 5"

  install_netcat
  check_project_directory

  echo ""
  log "üßπ Nettoyage YAML..."
  cleanup_yaml_errors

  echo ""
  log "üóÑÔ∏è Pr√©paration base de donn√©es..."
  if ! create_auth_schema; then
    echo ""
    error "‚ùå √âchec cr√©ation schema auth - Le script ne peut pas continuer"
    echo ""
    echo "üõ†Ô∏è **Solutions recommand√©es** :"
    echo "   1. V√©rifier entropie : cat /proc/sys/kernel/random/entropy_avail"
    echo "   2. Installer haveged : sudo apt install haveged"
    echo "   3. R√©initialisation compl√®te : ./reset-and-fix.sh"
    echo "   4. Diagnostic approfondi : ./diagnose-deep.sh"
    echo ""
    exit 1
  fi

  echo ""
  log "üè• √âtat avant corrections :"
  diagnose_restarting_services || true

  echo ""
  log "üõ†Ô∏è Application des corrections..."
  fix_auth_service
  fix_storage_service
  fix_realtime_service
  fix_edge_functions_service

  wait_for_stabilization
  show_final_status
}

main "$@"