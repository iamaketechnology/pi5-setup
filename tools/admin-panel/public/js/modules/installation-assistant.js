// =============================================================================
// Installation Assistant Module
// =============================================================================
// Intelligent assistant that guides users through Pi installation
// =============================================================================

import api from '../utils/api.js';
import terminalManager from './terminal.js';

class InstallationAssistant {
    constructor() {
        this.steps = [
            { id: 'docker', name: 'Docker', emoji: 'üê≥', required: true },
            { id: 'network', name: 'R√©seau', emoji: 'üì°', required: true },
            { id: 'security', name: 'S√©curit√©', emoji: 'üîí', required: true },
            { id: 'traefik', name: 'Traefik', emoji: 'üåê', required: false },
            { id: 'monitoring', name: 'Monitoring', emoji: 'üìä', required: false }
        ];
        this.currentStatus = {};
        this.messageCount = 0;
    }

    init() {
        console.log('‚úÖ Installation Assistant initialized');
        this.initSidebar();
        this.initQuickActions();
    }

    initSidebar() {
        // Handle category clicks (filter services)
        document.querySelectorAll('.category-item').forEach(categoryBtn => {
            categoryBtn.addEventListener('click', () => {
                const category = categoryBtn.dataset.category;

                // Remove active from all categories
                document.querySelectorAll('.category-item').forEach(item => item.classList.remove('active'));
                categoryBtn.classList.add('active');

                // Filter services
                if (category === 'all') {
                    this.showAllServices();
                } else if (category === 'backups') {
                    this.showBackupsList();
                } else {
                    this.filterServicesByCategory(category);
                }
            });
        });

        // Handle service card clicks
        document.querySelectorAll('.service-card').forEach(card => {
            const installBtn = card.querySelector('.service-install-btn');
            const type = card.dataset.install;

            // Click on button
            installBtn.addEventListener('click', (e) => {
                e.stopPropagation();
                this.handleQuickInstall(type, installBtn);
            });

            // Click on card (except button)
            card.addEventListener('click', (e) => {
                if (!e.target.closest('.service-install-btn')) {
                    // Highlight card and show details in assistant
                    this.showServiceDetails(type);
                }
            });
        });
    }

    showAllServices() {
        document.getElementById('category-title').textContent = 'Tous les services';
        document.getElementById('services-grid').style.display = 'grid';
        document.getElementById('backups-list').style.display = 'none';

        // Show all service cards
        document.querySelectorAll('.service-card').forEach(card => {
            card.classList.remove('hidden');
        });
    }

    filterServicesByCategory(category) {
        const categoryNames = {
            'infrastructure': 'Infrastructure',
            'webserver': 'Serveur Web',
            'security': 'S√©curit√©',
            'email': 'Email'
        };

        document.getElementById('category-title').textContent = categoryNames[category] || category;
        document.getElementById('services-grid').style.display = 'grid';
        document.getElementById('backups-list').style.display = 'none';

        // Show only services matching category
        document.querySelectorAll('.service-card').forEach(card => {
            if (card.dataset.category === category) {
                card.classList.remove('hidden');
            } else {
                card.classList.add('hidden');
            }
        });
    }

    showBackupsList() {
        document.getElementById('category-title').textContent = 'Gestion des backups';
        document.getElementById('services-grid').style.display = 'none';
        document.getElementById('backups-list').style.display = 'block';

        // Load backups for all services
        this.loadAllBackups();
    }

    async loadAllBackups() {
        const backupsList = document.getElementById('backups-list');
        backupsList.innerHTML = '<div class="loading"><i data-lucide="loader" size="32"></i><p>Chargement des backups...</p></div>';

        const piId = window.currentPiId || null;
        const services = ['supabase', 'pocketbase', 'vaultwarden', 'nginx', 'caddy'];

        let allBackups = [];

        for (const service of services) {
            try {
                const response = await fetch(`/api/setup/list-backups?piId=${piId}&service=${service}`);
                const data = await response.json();

                if (data.success && data.backups.length > 0) {
                    allBackups.push({ service, backups: data.backups });
                }
            } catch (error) {
                console.error(`Error loading backups for ${service}:`, error);
            }
        }

        if (allBackups.length === 0) {
            backupsList.innerHTML = `
                <p class="empty-state">
                    <i data-lucide="archive" size="48"></i>
                    <span>Aucun backup trouv√© sur le Pi</span>
                    <small style="opacity: 0.7; margin-top: 8px;">Les backups appara√Ætront ici apr√®s leur cr√©ation</small>
                </p>
            `;
            lucide.createIcons();
            return;
        }

        // Display backups grouped by service
        let html = '<div class="backups-by-service">';

        allBackups.forEach(({ service, backups }) => {
            html += `
                <div class="backup-service-group">
                    <h3><i data-lucide="${this.getServiceIcon(service)}" size="18"></i> ${this.getServiceName(service)} (${backups.length})</h3>
                    <div class="backup-items">
            `;

            backups.forEach(backup => {
                html += `
                    <div class="backup-item" data-service="${service}" data-backup="${backup.name}">
                        <div class="backup-info">
                            <div class="backup-name">${backup.name}</div>
                            <div class="backup-meta">
                                <span><i data-lucide="calendar" size="12"></i> ${backup.date}</span>
                                <span><i data-lucide="hard-drive" size="12"></i> ${backup.size}</span>
                            </div>
                        </div>
                        <button class="btn btn-sm btn-primary restore-backup-btn">
                            <i data-lucide="rotate-ccw" size="14"></i>
                            <span>Restaurer</span>
                        </button>
                    </div>
                `;
            });

            html += `
                    </div>
                </div>
            `;
        });

        html += '</div>';
        backupsList.innerHTML = html;
        lucide.createIcons();

        // Attach restore handlers
        document.querySelectorAll('.restore-backup-btn').forEach(btn => {
            btn.addEventListener('click', (e) => {
                const backupItem = e.target.closest('.backup-item');
                const service = backupItem.dataset.service;
                const backupName = backupItem.dataset.backup;

                // Find backup object
                const serviceBackups = allBackups.find(sb => sb.service === service);
                if (serviceBackups) {
                    const backup = serviceBackups.backups.find(b => b.name === backupName);
                    if (backup) {
                        this.generateRestoreScript(service, backup);
                    }
                }
            });
        });
    }

    getServiceIcon(service) {
        const icons = {
            'supabase': 'database',
            'pocketbase': 'package',
            'vaultwarden': 'key',
            'nginx': 'server',
            'caddy': 'shield',
            'appwrite': 'cloud',
            'tailscale': 'shield',
            'pihole': 'filter',
            'email-smtp': 'send'
        };
        return icons[service] || 'box';
    }

    showServiceDetails(type) {
        this.addMessage(
            `üì¶ ${this.getServiceName(type)}`,
            'user'
        );

        this.addMessage(
            `Pour installer ${this.getServiceName(type)}, clique sur le bouton "Installer" sur la carte du service, ou utilise l'une des options ci-dessous.`,
            'assistant',
            {
                actions: [
                    {
                        text: '‚ñ∂Ô∏è Installer maintenant',
                        action: () => {
                            const card = document.querySelector(`.service-card[data-install="${type}"]`);
                            const installBtn = card?.querySelector('.service-install-btn');
                            if (installBtn) {
                                this.handleQuickInstall(type, installBtn);
                            }
                        },
                        primary: true
                    },
                    {
                        text: 'üîÑ Voir les backups',
                        action: () => this.listBackups(type),
                        primary: false
                    }
                ]
            }
        );
    }

    initQuickActions() {
        // Handle quick installation action buttons (legacy - for old layout)
        document.querySelectorAll('.action-btn[data-install]').forEach(btn => {
            btn.addEventListener('click', async (e) => {
                const installType = btn.dataset.install;
                await this.handleQuickInstall(installType, btn);
            });
        });
    }

    async handleQuickInstall(type, btn) {
        const piId = window.currentPiId || null;

        // Step 1: Check if service already installed
        this.addMessage(
            `üîç V√©rification de l'√©tat du service...`,
            'assistant'
        );

        let serviceInstalled = false;
        let serviceDetails = null;

        try {
            const serviceResponse = await fetch(`/api/setup/check-service?piId=${piId}&service=${type}`);
            const serviceData = await serviceResponse.json();

            if (serviceData.installed) {
                serviceInstalled = true;
                serviceDetails = serviceData.details;

                this.addMessage(
                    `‚ö†Ô∏è ${this.getServiceName(type)} est d√©j√† install√© !`,
                    'assistant'
                );

                // Show service details
                let detailsMsg = `üìä √âtat actuel :\n`;
                if (serviceDetails.running) {
                    detailsMsg += `  ‚Ä¢ Statut : ‚úÖ En cours d'ex√©cution`;
                    if (serviceDetails.uptime) {
                        detailsMsg += ` (${serviceDetails.uptime})`;
                    }
                } else {
                    detailsMsg += `  ‚Ä¢ Statut : ‚è∏Ô∏è Arr√™t√©`;
                }
                if (serviceDetails.size) {
                    detailsMsg += `\n  ‚Ä¢ Espace utilis√© : ${serviceDetails.size}`;
                }

                this.addMessage(detailsMsg, 'assistant');

                // Ask user what to do
                this.addMessage(
                    `Que souhaitez-vous faire ?`,
                    'assistant',
                    {
                        actions: [
                            {
                                text: '‚úÖ Ignorer (garder l\'existant)',
                                action: () => {
                                    this.addMessage('Installation annul√©e - Service existant conserv√©', 'assistant');
                                    btn.classList.remove('loading');
                                    const originalIcon = btn.querySelector('i').getAttribute('data-lucide');
                                    btn.querySelector('i').setAttribute('data-lucide', originalIcon);
                                    lucide.createIcons();
                                },
                                primary: true
                            },
                            {
                                text: 'üîÑ Restaurer depuis un backup',
                                action: () => this.listBackups(type),
                                primary: false
                            },
                            {
                                text: 'üíæ Backup puis r√©installer',
                                action: () => this.generateBackupScript(type, btn),
                                primary: false
                            },
                            {
                                text: 'üóëÔ∏è Nettoyer et r√©installer (sans backup)',
                                action: () => this.proceedWithReinstall(type, btn, true),
                                primary: false
                            },
                            {
                                text: '‚ÑπÔ∏è Voir les conteneurs Docker',
                                action: () => window.tabsManager?.switchTab('docker'),
                                primary: false
                            }
                        ]
                    }
                );

                // Stop here and wait for user choice
                btn.classList.remove('loading');
                const originalIcon = btn.querySelector('i').getAttribute('data-lucide');
                btn.querySelector('i').setAttribute('data-lucide', originalIcon);
                lucide.createIcons();
                return;
            }
        } catch (error) {
            console.error('Failed to check service:', error);
        }

        // Step 2: Check prerequisites
        this.addMessage(
            `üîç V√©rification des pr√©requis...`,
            'assistant'
        );

        let needsBaseSetup = true;
        try {
            const response = await fetch(`/api/setup/check-prerequisites?piId=${piId}`);
            const data = await response.json();

            if (data.status === 'COMPLETE') {
                needsBaseSetup = false;
                this.addMessage(
                    `‚úÖ Pr√©requis d√©j√† install√©s ! (Docker, UFW, Fail2ban, Page size 4KB)`,
                    'assistant'
                );
                this.addMessage(
                    `üìä D√©tails : ${data.passed}/${data.total} v√©rifications r√©ussies`,
                    'assistant'
                );
            } else {
                this.addMessage(
                    `‚ö†Ô∏è Pr√©requis manquants (${data.passed || 0}/${data.total || 6} v√©rifications)`,
                    'assistant'
                );
            }
        } catch (error) {
            console.error('Failed to check prerequisites:', error);
            this.addMessage(
                `‚ö†Ô∏è Impossible de v√©rifier les pr√©requis - Installation compl√®te recommand√©e`,
                'assistant'
            );
        }

        // Proceed with installation
        this.proceedWithInstall(type, btn, needsBaseSetup);
    }

    getServiceName(type) {
        const names = {
            'supabase': 'Supabase',
            'pocketbase': 'PocketBase',
            'vaultwarden': 'Vaultwarden',
            'nginx': 'Nginx',
            'pihole': 'Pi-hole'
        };
        return names[type] || type;
    }

    async proceedWithReinstall(type, btn, cleanFirst) {
        this.addMessage(
            `üóëÔ∏è Pr√©paration de la r√©installation...`,
            'assistant'
        );

        if (cleanFirst) {
            this.addMessage(
                `‚ö†Ô∏è Avant de r√©installer, vous devez nettoyer l'installation existante.`,
                'assistant'
            );
            this.addMessage(
                `√âtapes recommand√©es :`,
                'assistant',
                {
                    description: '1. Sauvegarder vos donn√©es si n√©cessaire\n2. Arr√™ter et supprimer les conteneurs\n3. Supprimer les volumes (optionnel)\n4. Relancer l\'installation',
                    actions: [{
                        text: 'üóëÔ∏è G√©n√©rer script de nettoyage',
                        action: () => this.generateCleanupScript(type),
                        primary: true
                    }]
                }
            );
        }
    }

    generateCleanupScript(type) {
        const cleanupScripts = {
            'supabase': `# Nettoyage Supabase
docker compose -f ~/stacks/supabase/docker-compose.yml down --volumes
rm -rf ~/stacks/supabase
# Relancez ensuite le script d'installation`,
            'pocketbase': `# Nettoyage PocketBase
systemctl stop pocketbase
systemctl disable pocketbase
rm -rf ~/apps/pocketbase
rm /etc/systemd/system/pocketbase.service
systemctl daemon-reload`,
            'vaultwarden': `# Nettoyage Vaultwarden
docker compose -f ~/stacks/vaultwarden/docker-compose.yml down --volumes
rm -rf ~/stacks/vaultwarden`
        };

        const script = cleanupScripts[type] || `# Pas de script de nettoyage disponible pour ${type}`;

        this.addMessage(
            `üìã Script de nettoyage pour ${this.getServiceName(type)} :`,
            'assistant'
        );
        this.addMessage(
            `\`\`\`bash\n${script}\n\`\`\``,
            'assistant',
            {
                description: '‚ö†Ô∏è Attention : Cette op√©ration supprimera toutes les donn√©es du service !',
                actions: [{
                    text: 'üíæ Copier dans le terminal',
                    action: () => {
                        if (window.terminalManager) {
                            window.terminalManager.pasteCommand(script);
                        }
                    },
                    primary: true
                }]
            }
        );
    }

    generateBackupScript(type, btn) {
        const timestamp = '$(date +%Y%m%d_%H%M%S)';

        const backupScripts = {
            'supabase': `#!/bin/bash
# =============================================================================
# Backup Supabase - Sauvegarde compl√®te avant r√©installation
# =============================================================================
# Version: 1.0.0
# Last updated: 2025-01-20
# =============================================================================

set -euo pipefail

BACKUP_DIR=~/backups/supabase_${timestamp}
mkdir -p $BACKUP_DIR

echo "üì¶ D√©marrage backup Supabase..."
echo "üìÅ Destination: $BACKUP_DIR"

# 1. Backup PostgreSQL database
echo ""
echo "1Ô∏è‚É£ Backup de la base de donn√©es PostgreSQL..."
docker exec supabase-db pg_dumpall -U postgres > $BACKUP_DIR/database.sql
if [ -f "$BACKUP_DIR/database.sql" ]; then
    echo "   ‚úÖ Database SQL dump cr√©√© ($(du -sh $BACKUP_DIR/database.sql | cut -f1))"
else
    echo "   ‚ùå √âchec backup database"
    exit 1
fi

# 2. Backup volumes Docker
echo ""
echo "2Ô∏è‚É£ Backup des volumes Docker..."

# DB data volume
docker run --rm \\
    -v supabase_db_data:/data \\
    -v $BACKUP_DIR:/backup \\
    alpine tar czf /backup/db_data.tar.gz /data
echo "   ‚úÖ db_data.tar.gz cr√©√© ($(du -sh $BACKUP_DIR/db_data.tar.gz | cut -f1))"

# Storage volume (if exists)
if docker volume inspect supabase_storage_data &>/dev/null; then
    docker run --rm \\
        -v supabase_storage_data:/data \\
        -v $BACKUP_DIR:/backup \\
        alpine tar czf /backup/storage_data.tar.gz /data
    echo "   ‚úÖ storage_data.tar.gz cr√©√© ($(du -sh $BACKUP_DIR/storage_data.tar.gz | cut -f1))"
fi

# 3. Backup configuration files
echo ""
echo "3Ô∏è‚É£ Backup des fichiers de configuration..."
if [ -d ~/stacks/supabase ]; then
    cp -r ~/stacks/supabase $BACKUP_DIR/config
    echo "   ‚úÖ Configuration copi√©e"
fi

# 4. Backup .env file (si existant)
if [ -f ~/stacks/supabase/.env ]; then
    cp ~/stacks/supabase/.env $BACKUP_DIR/.env.backup
    echo "   ‚úÖ Fichier .env sauvegard√©"
fi

# 5. R√©sum√©
echo ""
echo "‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ"
echo "‚úÖ BACKUP SUPABASE TERMIN√â"
echo "‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ"
echo "üìÅ Emplacement : $BACKUP_DIR"
echo ""
echo "Contenu du backup :"
ls -lh $BACKUP_DIR
echo ""
echo "Espace utilis√© :"
du -sh $BACKUP_DIR
echo ""
echo "‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ"
echo "üí° Prochaines √©tapes :"
echo "   1. V√©rifiez le contenu du backup ci-dessus"
echo "   2. Lancez le nettoyage : docker compose down --volumes"
echo "   3. R√©installez Supabase"
echo "   4. Restaurez si besoin avec les fichiers .tar.gz"
echo "‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ"`,

            'pocketbase': `#!/bin/bash
# =============================================================================
# Backup PocketBase - Sauvegarde compl√®te avant r√©installation
# =============================================================================

set -euo pipefail

BACKUP_DIR=~/backups/pocketbase_${timestamp}
mkdir -p $BACKUP_DIR

echo "üì¶ D√©marrage backup PocketBase..."
echo "üìÅ Destination: $BACKUP_DIR"

# 1. Stop service
echo ""
echo "1Ô∏è‚É£ Arr√™t du service PocketBase..."
systemctl stop pocketbase
echo "   ‚úÖ Service arr√™t√©"

# 2. Backup database
echo ""
echo "2Ô∏è‚É£ Backup de la base de donn√©es..."
if [ -f ~/apps/pocketbase/pb_data/data.db ]; then
    cp ~/apps/pocketbase/pb_data/data.db $BACKUP_DIR/data.db
    echo "   ‚úÖ data.db sauvegard√© ($(du -sh $BACKUP_DIR/data.db | cut -f1))"
fi

# 3. Backup storage
echo ""
echo "3Ô∏è‚É£ Backup du storage (fichiers upload√©s)..."
if [ -d ~/apps/pocketbase/pb_data/storage ]; then
    tar czf $BACKUP_DIR/storage.tar.gz -C ~/apps/pocketbase/pb_data storage
    echo "   ‚úÖ storage.tar.gz cr√©√© ($(du -sh $BACKUP_DIR/storage.tar.gz | cut -f1))"
fi

# 4. Backup logs
echo ""
echo "4Ô∏è‚É£ Backup des logs..."
if [ -d ~/apps/pocketbase/pb_data/logs ]; then
    tar czf $BACKUP_DIR/logs.tar.gz -C ~/apps/pocketbase/pb_data logs
    echo "   ‚úÖ logs.tar.gz cr√©√©"
fi

# 5. Backup configuration
echo ""
echo "5Ô∏è‚É£ Backup de la configuration..."
if [ -d ~/apps/pocketbase ]; then
    cp -r ~/apps/pocketbase $BACKUP_DIR/config
    echo "   ‚úÖ Configuration copi√©e"
fi

# 6. Restart service
echo ""
echo "6Ô∏è‚É£ Red√©marrage du service..."
systemctl start pocketbase
echo "   ‚úÖ Service red√©marr√©"

# R√©sum√©
echo ""
echo "‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ"
echo "‚úÖ BACKUP POCKETBASE TERMIN√â"
echo "‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ"
echo "üìÅ Emplacement : $BACKUP_DIR"
echo ""
ls -lh $BACKUP_DIR
echo ""
du -sh $BACKUP_DIR
echo "‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ"`,

            'vaultwarden': `#!/bin/bash
# =============================================================================
# Backup Vaultwarden - Sauvegarde compl√®te avant r√©installation
# =============================================================================

set -euo pipefail

BACKUP_DIR=~/backups/vaultwarden_${timestamp}
mkdir -p $BACKUP_DIR

echo "üì¶ D√©marrage backup Vaultwarden..."
echo "üìÅ Destination: $BACKUP_DIR"

# 1. Backup SQLite database
echo ""
echo "1Ô∏è‚É£ Backup de la base de donn√©es SQLite..."
docker exec vaultwarden sqlite3 /data/db.sqlite3 ".backup '/data/backup.sqlite3'"
docker cp vaultwarden:/data/backup.sqlite3 $BACKUP_DIR/db.sqlite3
echo "   ‚úÖ db.sqlite3 sauvegard√© ($(du -sh $BACKUP_DIR/db.sqlite3 | cut -f1))"

# 2. Backup attachments
echo ""
echo "2Ô∏è‚É£ Backup des pi√®ces jointes..."
docker run --rm \\
    -v vaultwarden_data:/data \\
    -v $BACKUP_DIR:/backup \\
    alpine tar czf /backup/attachments.tar.gz /data/attachments 2>/dev/null || echo "   ‚ö†Ô∏è Pas de pi√®ces jointes"

# 3. Backup configuration
echo ""
echo "3Ô∏è‚É£ Backup de la configuration..."
if [ -d ~/stacks/vaultwarden ]; then
    cp -r ~/stacks/vaultwarden $BACKUP_DIR/config
    echo "   ‚úÖ Configuration copi√©e"
fi

# 4. Backup .env
if [ -f ~/stacks/vaultwarden/.env ]; then
    cp ~/stacks/vaultwarden/.env $BACKUP_DIR/.env.backup
    echo "   ‚úÖ .env sauvegard√©"
fi

# 5. Backup entire data volume
echo ""
echo "4Ô∏è‚É£ Backup du volume complet..."
docker run --rm \\
    -v vaultwarden_data:/data \\
    -v $BACKUP_DIR:/backup \\
    alpine tar czf /backup/vaultwarden_data_full.tar.gz /data
echo "   ‚úÖ vaultwarden_data_full.tar.gz cr√©√© ($(du -sh $BACKUP_DIR/vaultwarden_data_full.tar.gz | cut -f1))"

# R√©sum√©
echo ""
echo "‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ"
echo "‚úÖ BACKUP VAULTWARDEN TERMIN√â"
echo "‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ"
echo "üìÅ Emplacement : $BACKUP_DIR"
echo ""
ls -lh $BACKUP_DIR
echo ""
du -sh $BACKUP_DIR
echo ""
echo "‚ö†Ô∏è IMPORTANT : Conservez ce backup dans un endroit s√ªr !"
echo "‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ"`,

            'nginx': `#!/bin/bash
# =============================================================================
# Backup Nginx - Sauvegarde compl√®te avant r√©installation
# =============================================================================

set -euo pipefail

BACKUP_DIR=~/backups/nginx_${timestamp}
mkdir -p $BACKUP_DIR

echo "üì¶ D√©marrage backup Nginx..."

# 1. Backup configuration
echo ""
echo "1Ô∏è‚É£ Backup de la configuration Nginx..."
if [ -d ~/stacks/nginx ]; then
    cp -r ~/stacks/nginx $BACKUP_DIR/config
    echo "   ‚úÖ Configuration copi√©e"
fi

# 2. Backup SSL certificates
echo ""
echo "2Ô∏è‚É£ Backup des certificats SSL..."
docker run --rm \\
    -v nginx_certs:/certs \\
    -v $BACKUP_DIR:/backup \\
    alpine tar czf /backup/ssl_certs.tar.gz /certs 2>/dev/null || echo "   ‚ö†Ô∏è Pas de certificats"

# 3. Backup static content (if any)
if docker volume inspect nginx_html &>/dev/null; then
    echo ""
    echo "3Ô∏è‚É£ Backup du contenu statique..."
    docker run --rm \\
        -v nginx_html:/html \\
        -v $BACKUP_DIR:/backup \\
        alpine tar czf /backup/html.tar.gz /html
    echo "   ‚úÖ html.tar.gz cr√©√©"
fi

echo ""
echo "‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ"
echo "‚úÖ BACKUP NGINX TERMIN√â"
echo "‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ"
echo "üìÅ Emplacement : $BACKUP_DIR"
ls -lh $BACKUP_DIR
echo "‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ"`
        };

        const script = backupScripts[type];

        if (!script) {
            this.addMessage(
                `‚ùå Pas de script de backup disponible pour ${this.getServiceName(type)}`,
                'assistant'
            );
            return;
        }

        this.addMessage(
            `üìã Script de backup pour ${this.getServiceName(type)} :`,
            'assistant'
        );

        this.addMessage(
            `\`\`\`bash\n${script}\n\`\`\``,
            'assistant',
            {
                description: 'üíæ Ce script va cr√©er une sauvegarde compl√®te dans ~/backups/',
                actions: [
                    {
                        text: '‚ñ∂Ô∏è Ex√©cuter le backup',
                        action: () => {
                            if (window.terminalManager) {
                                window.terminalManager.pasteCommand(script);
                            }
                        },
                        primary: true
                    },
                    {
                        text: 'üìã Copier le script',
                        action: () => {
                            navigator.clipboard.writeText(script).then(() => {
                                this.addMessage('‚úÖ Script copi√© dans le presse-papier', 'assistant');
                            });
                        },
                        primary: false
                    },
                    {
                        text: 'üîÑ Backup termin√©, continuer la r√©installation',
                        action: () => {
                            this.proceedWithReinstall(type, btn, true);
                        },
                        primary: false
                    }
                ]
            }
        );
    }

    async listBackups(type) {
        const piId = window.currentPiId || null;

        this.addMessage(
            `üîç Recherche des backups pour ${this.getServiceName(type)}...`,
            'assistant'
        );

        try {
            const response = await fetch(`/api/setup/list-backups?piId=${piId}&service=${type}`);
            const data = await response.json();

            if (!data.success) {
                this.addMessage(`‚ùå Erreur: ${data.error}`, 'assistant');
                return;
            }

            if (data.backups.length === 0) {
                this.addMessage(
                    `üìÅ Aucun backup trouv√© pour ${this.getServiceName(type)} dans ~/backups/`,
                    'assistant'
                );
                this.addMessage(
                    `üí° Cr√©ez un backup avant de r√©installer pour sauvegarder vos donn√©es.`,
                    'assistant'
                );
                return;
            }

            // Display backups list
            this.addMessage(
                `üì¶ ${data.backups.length} backup(s) trouv√©(s) pour ${this.getServiceName(type)} :`,
                'assistant'
            );

            let backupsList = '\n';
            data.backups.forEach((backup, index) => {
                backupsList += `${index + 1}. üìÅ ${backup.name}\n`;
                backupsList += `   üìÖ Date: ${backup.date}\n`;
                backupsList += `   üíæ Taille: ${backup.size}\n`;
                backupsList += `   üìÇ Contenu: ${backup.files.join(', ')}\n\n`;
            });

            this.addMessage(
                `\`\`\`${backupsList}\`\`\``,
                'assistant'
            );

            // Add restore options
            this.addMessage(
                `Que souhaitez-vous faire ?`,
                'assistant',
                {
                    actions: data.backups.map((backup, index) => ({
                        text: `üîÑ Restaurer "${backup.name}"`,
                        action: () => this.generateRestoreScript(type, backup),
                        primary: index === 0 // Most recent is primary
                    })).concat([
                        {
                            text: '‚ùå Annuler',
                            action: () => {
                                this.addMessage('‚úÖ Op√©ration annul√©e', 'assistant');
                            },
                            primary: false
                        }
                    ])
                }
            );

        } catch (error) {
            this.addMessage(`‚ùå Erreur lors de la r√©cup√©ration des backups: ${error.message}`, 'assistant');
        }
    }

    generateRestoreScript(type, backup) {
        const backupPath = backup.path;

        const restoreScripts = {
            'supabase': `#!/bin/bash
# =============================================================================
# Restore Supabase - Restauration depuis backup
# =============================================================================
# Backup: ${backup.name}
# Date: ${backup.date}
# =============================================================================

set -euo pipefail

BACKUP_DIR="${backupPath}"

echo "üîÑ Restauration de Supabase depuis backup..."
echo "üìÅ Source: $BACKUP_DIR"
echo ""

# 1. V√©rifier que le backup existe
if [ ! -d "$BACKUP_DIR" ]; then
    echo "‚ùå Erreur: Backup introuvable √† $BACKUP_DIR"
    exit 1
fi

# 2. Arr√™ter Supabase
echo "1Ô∏è‚É£ Arr√™t de Supabase..."
cd ~/stacks/supabase
docker compose down
echo "   ‚úÖ Supabase arr√™t√©"

# 3. Restaurer les volumes Docker
echo ""
echo "2Ô∏è‚É£ Restauration des volumes Docker..."

# Restaurer db_data
if [ -f "$BACKUP_DIR/db_data.tar.gz" ]; then
    docker volume rm supabase_db_data 2>/dev/null || true
    docker volume create supabase_db_data
    docker run --rm \\
        -v supabase_db_data:/data \\
        -v $BACKUP_DIR:/backup \\
        alpine sh -c "cd / && tar xzf /backup/db_data.tar.gz"
    echo "   ‚úÖ db_data restaur√©"
else
    echo "   ‚ö†Ô∏è db_data.tar.gz introuvable"
fi

# Restaurer storage_data
if [ -f "$BACKUP_DIR/storage_data.tar.gz" ]; then
    docker volume rm supabase_storage_data 2>/dev/null || true
    docker volume create supabase_storage_data
    docker run --rm \\
        -v supabase_storage_data:/data \\
        -v $BACKUP_DIR:/backup \\
        alpine sh -c "cd / && tar xzf /backup/storage_data.tar.gz"
    echo "   ‚úÖ storage_data restaur√©"
fi

# 4. Restaurer la configuration
echo ""
echo "3Ô∏è‚É£ Restauration de la configuration..."
if [ -d "$BACKUP_DIR/config" ]; then
    cp -r $BACKUP_DIR/config/* ~/stacks/supabase/
    echo "   ‚úÖ Configuration restaur√©e"
fi

# 5. Restaurer .env
if [ -f "$BACKUP_DIR/.env.backup" ]; then
    cp $BACKUP_DIR/.env.backup ~/stacks/supabase/.env
    echo "   ‚úÖ .env restaur√©"
fi

# 6. Red√©marrer Supabase
echo ""
echo "4Ô∏è‚É£ Red√©marrage de Supabase..."
cd ~/stacks/supabase
docker compose up -d
echo "   ‚úÖ Supabase red√©marr√©"

# 7. Restaurer la base de donn√©es (si dump SQL disponible)
echo ""
echo "5Ô∏è‚É£ Restauration de la base de donn√©es..."
if [ -f "$BACKUP_DIR/database.sql" ]; then
    echo "   ‚è≥ Attente d√©marrage PostgreSQL (30s)..."
    sleep 30

    docker exec -i supabase-db psql -U postgres < $BACKUP_DIR/database.sql
    echo "   ‚úÖ Base de donn√©es restaur√©e"
else
    echo "   ‚ö†Ô∏è database.sql introuvable"
fi

# R√©sum√©
echo ""
echo "‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ"
echo "‚úÖ RESTAURATION SUPABASE TERMIN√âE"
echo "‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ"
echo "üìä V√©rifiez l'√©tat des services :"
echo "   docker ps | grep supabase"
echo ""
echo "üåê Acc√®s :"
echo "   http://localhost:8001 (Kong API)"
echo "   http://localhost:54321 (Edge Functions)"
echo "‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ"`,

            'pocketbase': `#!/bin/bash
# =============================================================================
# Restore PocketBase - Restauration depuis backup
# =============================================================================
# Backup: ${backup.name}
# Date: ${backup.date}
# =============================================================================

set -euo pipefail

BACKUP_DIR="${backupPath}"

echo "üîÑ Restauration de PocketBase depuis backup..."
echo "üìÅ Source: $BACKUP_DIR"
echo ""

# 1. V√©rifier backup
if [ ! -d "$BACKUP_DIR" ]; then
    echo "‚ùå Backup introuvable: $BACKUP_DIR"
    exit 1
fi

# 2. Arr√™ter PocketBase
echo "1Ô∏è‚É£ Arr√™t de PocketBase..."
systemctl stop pocketbase
echo "   ‚úÖ Service arr√™t√©"

# 3. Restaurer database
echo ""
echo "2Ô∏è‚É£ Restauration de la base de donn√©es..."
if [ -f "$BACKUP_DIR/data.db" ]; then
    cp $BACKUP_DIR/data.db ~/apps/pocketbase/pb_data/data.db
    echo "   ‚úÖ data.db restaur√© ($(du -sh ~/apps/pocketbase/pb_data/data.db | cut -f1))"
else
    echo "   ‚ùå data.db introuvable dans le backup"
    exit 1
fi

# 4. Restaurer storage
echo ""
echo "3Ô∏è‚É£ Restauration du storage..."
if [ -f "$BACKUP_DIR/storage.tar.gz" ]; then
    rm -rf ~/apps/pocketbase/pb_data/storage
    tar xzf $BACKUP_DIR/storage.tar.gz -C ~/apps/pocketbase/pb_data
    echo "   ‚úÖ Storage restaur√©"
fi

# 5. Restaurer logs
if [ -f "$BACKUP_DIR/logs.tar.gz" ]; then
    tar xzf $BACKUP_DIR/logs.tar.gz -C ~/apps/pocketbase/pb_data
    echo "   ‚úÖ Logs restaur√©s"
fi

# 6. Restaurer configuration
echo ""
echo "4Ô∏è‚É£ Restauration de la configuration..."
if [ -d "$BACKUP_DIR/config" ]; then
    cp -r $BACKUP_DIR/config/* ~/apps/pocketbase/ 2>/dev/null || true
    echo "   ‚úÖ Configuration restaur√©e"
fi

# 7. Red√©marrer
echo ""
echo "5Ô∏è‚É£ Red√©marrage de PocketBase..."
systemctl start pocketbase
sleep 3

if systemctl is-active --quiet pocketbase; then
    echo "   ‚úÖ PocketBase red√©marr√© avec succ√®s"
else
    echo "   ‚ùå √âchec red√©marrage - V√©rifiez les logs: journalctl -u pocketbase -n 50"
    exit 1
fi

echo ""
echo "‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ"
echo "‚úÖ RESTAURATION POCKETBASE TERMIN√âE"
echo "‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ"
echo "üåê Admin UI: http://localhost:8090/_/"
echo "üìä Status: systemctl status pocketbase"
echo "‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ"`,

            'vaultwarden': `#!/bin/bash
# =============================================================================
# Restore Vaultwarden - Restauration depuis backup
# =============================================================================
# Backup: ${backup.name}
# Date: ${backup.date}
# =============================================================================

set -euo pipefail

BACKUP_DIR="${backupPath}"

echo "üîÑ Restauration de Vaultwarden depuis backup..."
echo "üìÅ Source: $BACKUP_DIR"
echo ""

# 1. V√©rifier backup
if [ ! -d "$BACKUP_DIR" ]; then
    echo "‚ùå Backup introuvable: $BACKUP_DIR"
    exit 1
fi

# 2. Arr√™ter Vaultwarden
echo "1Ô∏è‚É£ Arr√™t de Vaultwarden..."
cd ~/stacks/vaultwarden
docker compose down
echo "   ‚úÖ Vaultwarden arr√™t√©"

# 3. Restaurer le volume complet
echo ""
echo "2Ô∏è‚É£ Restauration du volume de donn√©es..."
if [ -f "$BACKUP_DIR/vaultwarden_data_full.tar.gz" ]; then
    docker volume rm vaultwarden_data 2>/dev/null || true
    docker volume create vaultwarden_data
    docker run --rm \\
        -v vaultwarden_data:/data \\
        -v $BACKUP_DIR:/backup \\
        alpine sh -c "cd / && tar xzf /backup/vaultwarden_data_full.tar.gz"
    echo "   ‚úÖ Volume complet restaur√©"
fi

# 4. Restaurer configuration
echo ""
echo "3Ô∏è‚É£ Restauration de la configuration..."
if [ -d "$BACKUP_DIR/config" ]; then
    cp -r $BACKUP_DIR/config/* ~/stacks/vaultwarden/
    echo "   ‚úÖ Configuration restaur√©e"
fi

# 5. Restaurer .env
if [ -f "$BACKUP_DIR/.env.backup" ]; then
    cp $BACKUP_DIR/.env.backup ~/stacks/vaultwarden/.env
    echo "   ‚úÖ .env restaur√©"
fi

# 6. Red√©marrer
echo ""
echo "4Ô∏è‚É£ Red√©marrage de Vaultwarden..."
cd ~/stacks/vaultwarden
docker compose up -d
echo "   ‚úÖ Vaultwarden red√©marr√©"

echo ""
echo "‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ"
echo "‚úÖ RESTAURATION VAULTWARDEN TERMIN√âE"
echo "‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ"
echo "‚ö†Ô∏è IMPORTANT: Testez la connexion avec vos identifiants"
echo "üåê URL: http://localhost:8080"
echo "üìä Logs: docker logs vaultwarden --tail 50"
echo "‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ"`,

            'nginx': `#!/bin/bash
# =============================================================================
# Restore Nginx - Restauration depuis backup
# =============================================================================
# Backup: ${backup.name}
# Date: ${backup.date}
# =============================================================================

set -euo pipefail

BACKUP_DIR="${backupPath}"

echo "üîÑ Restauration de Nginx depuis backup..."
echo "üìÅ Source: $BACKUP_DIR"
echo ""

# 1. V√©rifier backup
if [ ! -d "$BACKUP_DIR" ]; then
    echo "‚ùå Backup introuvable: $BACKUP_DIR"
    exit 1
fi

# 2. Arr√™ter Nginx
echo "1Ô∏è‚É£ Arr√™t de Nginx..."
cd ~/stacks/nginx
docker compose down
echo "   ‚úÖ Nginx arr√™t√©"

# 3. Restaurer certificats SSL
echo ""
echo "2Ô∏è‚É£ Restauration des certificats SSL..."
if [ -f "$BACKUP_DIR/ssl_certs.tar.gz" ]; then
    docker volume rm nginx_certs 2>/dev/null || true
    docker volume create nginx_certs
    docker run --rm \\
        -v nginx_certs:/certs \\
        -v $BACKUP_DIR:/backup \\
        alpine sh -c "cd / && tar xzf /backup/ssl_certs.tar.gz"
    echo "   ‚úÖ Certificats SSL restaur√©s"
fi

# 4. Restaurer contenu statique
if [ -f "$BACKUP_DIR/html.tar.gz" ]; then
    echo ""
    echo "3Ô∏è‚É£ Restauration du contenu statique..."
    docker volume rm nginx_html 2>/dev/null || true
    docker volume create nginx_html
    docker run --rm \\
        -v nginx_html:/html \\
        -v $BACKUP_DIR:/backup \\
        alpine sh -c "cd / && tar xzf /backup/html.tar.gz"
    echo "   ‚úÖ Contenu HTML restaur√©"
fi

# 5. Restaurer configuration
echo ""
echo "4Ô∏è‚É£ Restauration de la configuration..."
if [ -d "$BACKUP_DIR/config" ]; then
    cp -r $BACKUP_DIR/config/* ~/stacks/nginx/
    echo "   ‚úÖ Configuration restaur√©e"
fi

# 6. Red√©marrer
echo ""
echo "5Ô∏è‚É£ Red√©marrage de Nginx..."
cd ~/stacks/nginx
docker compose up -d
echo "   ‚úÖ Nginx red√©marr√©"

echo ""
echo "‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ"
echo "‚úÖ RESTAURATION NGINX TERMIN√âE"
echo "‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ"
echo "üåê Testez vos sites web"
echo "üìä Logs: docker logs nginx --tail 50"
echo "‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ"`
        };

        const script = restoreScripts[type];

        if (!script) {
            this.addMessage(
                `‚ùå Pas de script de restauration disponible pour ${this.getServiceName(type)}`,
                'assistant'
            );
            return;
        }

        this.addMessage(
            `üìã Script de restauration pour ${this.getServiceName(type)} :`,
            'assistant'
        );

        this.addMessage(
            `\`\`\`bash\n${script}\n\`\`\``,
            'assistant',
            {
                description: `üîÑ Ce script va restaurer ${this.getServiceName(type)} depuis le backup "${backup.name}"`,
                actions: [
                    {
                        text: '‚ñ∂Ô∏è Ex√©cuter la restauration',
                        action: () => {
                            if (window.terminalManager) {
                                window.terminalManager.pasteCommand(script);
                            }
                        },
                        primary: true
                    },
                    {
                        text: 'üìã Copier le script',
                        action: () => {
                            navigator.clipboard.writeText(script).then(() => {
                                this.addMessage('‚úÖ Script copi√© dans le presse-papier', 'assistant');
                            });
                        },
                        primary: false
                    },
                    {
                        text: 'üîç Voir d\'autres backups',
                        action: () => this.listBackups(type),
                        primary: false
                    }
                ]
            }
        );
    }

    proceedWithInstall(type, btn, needsBaseSetup) {

        const installConfigs = {
            'supabase': {
                name: 'Supabase',
                emoji: 'üóÑÔ∏è',
                baseSetupRequired: true,
                steps: [
                    {
                        name: 'Pi5 Base Setup (Prerequisites)',
                        command: 'curl -fsSL https://raw.githubusercontent.com/iamaketechnology/pi5-setup/main/common-scripts/01-pi5-base-setup.sh | sudo bash',
                        description: 'Installation Docker, UFW, Fail2ban, optimisations Pi 5 (requis pour tous les services)',
                        required: needsBaseSetup,
                        skipMessage: '‚úÖ Pr√©requis d√©j√† install√©s - √âtape ignor√©e'
                    },
                    {
                        name: 'Supabase Deployment',
                        command: 'curl -fsSL https://raw.githubusercontent.com/iamaketechnology/pi5-setup/main/01-infrastructure/supabase/scripts/02-supabase-deploy.sh | sudo bash',
                        description: 'D√©ploiement PostgreSQL, Auth, Storage, Edge Functions (ouvre automatiquement les ports 8001, 54321)',
                        required: true
                    }
                ]
            },
            'pocketbase': {
                name: 'PocketBase',
                emoji: 'üì¶',
                baseSetupRequired: true,
                steps: [
                    {
                        name: 'Pi5 Base Setup (Prerequisites)',
                        command: 'curl -fsSL https://raw.githubusercontent.com/iamaketechnology/pi5-setup/main/common-scripts/01-pi5-base-setup.sh | sudo bash',
                        description: 'Installation Docker, UFW, Fail2ban (requis)',
                        required: needsBaseSetup,
                        skipMessage: '‚úÖ Pr√©requis d√©j√† install√©s'
                    },
                    {
                        name: 'PocketBase Deployment',
                        command: 'curl -fsSL https://raw.githubusercontent.com/iamaketechnology/pi5-setup/main/01-infrastructure/pocketbase/scripts/01-pocketbase-deploy.sh | sudo bash',
                        description: 'Backend-as-a-Service l√©ger avec base de donn√©es int√©gr√©e',
                        required: true
                    }
                ]
            },
            'appwrite': {
                name: 'Appwrite',
                emoji: '‚òÅÔ∏è',
                baseSetupRequired: true,
                steps: [
                    {
                        name: 'Pi5 Base Setup (Prerequisites)',
                        command: 'curl -fsSL https://raw.githubusercontent.com/iamaketechnology/pi5-setup/main/common-scripts/01-pi5-base-setup.sh | sudo bash',
                        description: 'Installation Docker (requis)',
                        required: needsBaseSetup,
                        skipMessage: '‚úÖ Pr√©requis d√©j√† install√©s'
                    },
                    {
                        name: 'Appwrite Deployment',
                        command: 'curl -fsSL https://raw.githubusercontent.com/iamaketechnology/pi5-setup/main/01-infrastructure/appwrite/scripts/01-appwrite-deploy.sh | sudo bash',
                        description: 'Backend complet avec APIs, Auth, Database, Storage',
                        required: true
                    }
                ]
            },
            'nginx': {
                name: 'Nginx',
                emoji: 'üåê',
                baseSetupRequired: true,
                steps: [
                    {
                        name: 'Pi5 Base Setup (Prerequisites)',
                        command: 'curl -fsSL https://raw.githubusercontent.com/iamaketechnology/pi5-setup/main/common-scripts/01-pi5-base-setup.sh | sudo bash',
                        description: 'Installation Docker (requis)',
                        required: needsBaseSetup,
                        skipMessage: '‚úÖ Pr√©requis d√©j√† install√©s'
                    },
                    {
                        name: 'Nginx Deployment',
                        command: 'curl -fsSL https://raw.githubusercontent.com/iamaketechnology/pi5-setup/main/01-infrastructure/webserver/scripts/01-nginx-deploy.sh | sudo bash',
                        description: 'Reverse proxy haute performance',
                        required: true
                    }
                ]
            },
            'caddy': {
                name: 'Caddy',
                emoji: 'üîí',
                baseSetupRequired: true,
                steps: [
                    {
                        name: 'Pi5 Base Setup (Prerequisites)',
                        command: 'curl -fsSL https://raw.githubusercontent.com/iamaketechnology/pi5-setup/main/common-scripts/01-pi5-base-setup.sh | sudo bash',
                        description: 'Installation Docker (requis)',
                        required: needsBaseSetup,
                        skipMessage: '‚úÖ Pr√©requis d√©j√† install√©s'
                    },
                    {
                        name: 'Caddy Deployment',
                        command: 'curl -fsSL https://raw.githubusercontent.com/iamaketechnology/pi5-setup/main/01-infrastructure/webserver/scripts/01-caddy-deploy.sh | sudo bash',
                        description: 'Serveur web avec HTTPS automatique',
                        required: true
                    }
                ]
            },
            'vaultwarden': {
                name: 'Vaultwarden',
                emoji: 'üîë',
                baseSetupRequired: true,
                steps: [
                    {
                        name: 'Pi5 Base Setup (Prerequisites)',
                        command: 'curl -fsSL https://raw.githubusercontent.com/iamaketechnology/pi5-setup/main/common-scripts/01-pi5-base-setup.sh | sudo bash',
                        description: 'Installation Docker (requis)',
                        required: needsBaseSetup,
                        skipMessage: '‚úÖ Pr√©requis d√©j√† install√©s'
                    },
                    {
                        name: 'Vaultwarden Deployment',
                        command: 'curl -fsSL https://raw.githubusercontent.com/iamaketechnology/pi5-setup/main/01-infrastructure/vaultwarden/scripts/01-vaultwarden-deploy.sh | sudo bash',
                        description: 'Gestionnaire de mots de passe auto-h√©berg√©',
                        required: true
                    }
                ]
            },
            'tailscale': {
                name: 'Tailscale',
                emoji: 'üõ°Ô∏è',
                baseSetupRequired: false, // Tailscale ne n√©cessite pas Docker
                steps: [{
                    name: 'Tailscale Setup',
                    command: 'curl -fsSL https://raw.githubusercontent.com/iamaketechnology/pi5-setup/main/01-infrastructure/vpn-wireguard/scripts/01-tailscale-setup.sh | sudo bash',
                    description: 'VPN zero-config mesh network',
                    required: true
                }]
            },
            'pihole': {
                name: 'Pi-hole',
                emoji: 'üõ°Ô∏è',
                baseSetupRequired: true,
                steps: [
                    {
                        name: 'Pi5 Base Setup (Prerequisites)',
                        command: 'curl -fsSL https://raw.githubusercontent.com/iamaketechnology/pi5-setup/main/common-scripts/01-pi5-base-setup.sh | sudo bash',
                        description: 'Installation Docker (requis)',
                        required: needsBaseSetup,
                        skipMessage: '‚úÖ Pr√©requis d√©j√† install√©s'
                    },
                    {
                        name: 'Pi-hole Deployment',
                        command: 'curl -fsSL https://raw.githubusercontent.com/iamaketechnology/pi5-setup/main/01-infrastructure/pihole/scripts/01-pihole-deploy.sh | sudo bash',
                        description: 'Bloqueur de publicit√©s au niveau r√©seau',
                        required: true
                    }
                ]
            },
            'email-smtp': {
                name: 'SMTP Email',
                emoji: 'üìß',
                baseSetupRequired: false, // SMTP setup ne n√©cessite pas Docker
                steps: [{
                    name: 'Email Provider Setup',
                    command: 'curl -fsSL https://raw.githubusercontent.com/iamaketechnology/pi5-setup/main/01-infrastructure/email/scripts/01-email-provider-setup.sh | sudo bash',
                    description: 'Configuration SMTP (Resend, SendGrid, SMTP externe)',
                    required: true
                }]
            }
        };

        const config = installConfigs[type];
        if (!config) {
            console.error('Unknown installation type:', type);
            return;
        }

        // Update button state
        btn.classList.add('loading');
        const originalIcon = btn.querySelector('i').getAttribute('data-lucide');
        btn.querySelector('i').setAttribute('data-lucide', 'loader');
        lucide.createIcons();

        // Filter required steps
        const requiredSteps = config.steps.filter(step => step.required !== false);
        const skippedSteps = config.steps.filter(step => step.required === false);

        // Add welcome message
        this.addMessage(
            `Installation de ${config.emoji} ${config.name}`,
            'user'
        );

        if (skippedSteps.length > 0) {
            this.addMessage(
                `‚úÖ ${skippedSteps.length} √©tape${skippedSteps.length > 1 ? 's' : ''} ignor√©e${skippedSteps.length > 1 ? 's' : ''} (d√©j√† install√©e${skippedSteps.length > 1 ? 's' : ''})`,
                'assistant'
            );
            skippedSteps.forEach(step => {
                this.addMessage(
                    `‚è≠Ô∏è ${step.name} : ${step.skipMessage || 'D√©j√† install√©'}`,
                    'assistant'
                );
            });
        }

        if (requiredSteps.length === 0) {
            this.addMessage(
                `‚úÖ ${config.name} semble d√©j√† compl√®tement install√© ! V√©rifiez l'onglet Docker ou Services.`,
                'assistant'
            );
            btn.classList.remove('loading');
            btn.querySelector('i').setAttribute('data-lucide', originalIcon);
            lucide.createIcons();
            return;
        }

        this.addMessage(
            `Parfait ! Je vais installer ${config.name} en ${requiredSteps.length} √©tape${requiredSteps.length > 1 ? 's' : ''}.`,
            'assistant'
        );

        // Execute required steps only
        for (let i = 0; i < requiredSteps.length; i++) {
            const step = requiredSteps[i];

            this.addMessage(
                `üìå √âtape ${i + 1}/${requiredSteps.length} : ${step.name}`,
                'assistant',
                {
                    description: step.description,
                    actions: [{
                        text: '‚ñ∂Ô∏è Lancer',
                        command: step.command,
                        primary: true
                    }]
                }
            );
        }

        // Add final message
        this.addMessage(
            `üí° Clique sur les boutons "‚ñ∂Ô∏è Lancer" ci-dessus pour ex√©cuter chaque √©tape. Le terminal s'ouvrira automatiquement pour suivre l'installation.`,
            'assistant'
        );

        // Reset button state
        btn.classList.remove('loading');
        btn.querySelector('i').setAttribute('data-lucide', originalIcon);
        lucide.createIcons();
    }

    async load() {
        try {
            // Get setup status
            const data = await api.get('/setup-status');
            this.currentStatus = data.status || {};

            // Render progress
            this.renderProgress();

            // Analyze and suggest next step
            this.analyzeSituation();
        } catch (error) {
            console.error('Failed to load installation status:', error);
            this.addMessage('‚ùå Impossible de v√©rifier l\'√©tat du Pi. V√©rifie ta connexion SSH.', 'error');
        }
    }

    renderProgress() {
        const stepsContainer = document.getElementById('install-progress-steps');
        if (!stepsContainer) return;

        const completedSteps = this.steps.filter(step => this.isStepCompleted(step.id));
        const progress = Math.round((completedSteps.length / this.steps.length) * 100);

        // Update progress bar
        const progressFill = document.getElementById('install-progress-fill');
        const progressPercent = document.getElementById('install-progress-percent');
        if (progressFill) progressFill.style.width = `${progress}%`;
        if (progressPercent) progressPercent.textContent = `${progress}%`;

        // Render steps
        stepsContainer.innerHTML = this.steps.map(step => {
            const completed = this.isStepCompleted(step.id);
            const current = this.isCurrentStep(step.id);

            let statusClass = 'pending';
            let statusIcon = '‚è∏Ô∏è';

            if (completed) {
                statusClass = 'completed';
                statusIcon = '‚úÖ';
            } else if (current) {
                statusClass = 'active';
                statusIcon = 'üîß';
            }

            return `
                <div class="step ${statusClass}">
                    <span class="step-icon">${statusIcon}</span>
                    <span class="step-name">${step.emoji} ${step.name}</span>
                </div>
            `;
        }).join('');
    }

    isStepCompleted(stepId) {
        switch (stepId) {
            case 'docker':
                return this.currentStatus.docker === true;
            case 'network':
                return this.currentStatus.network?.configured === true;
            case 'security':
                return this.currentStatus.security?.configured === true;
            case 'traefik':
                return this.currentStatus.traefik?.running === true;
            case 'monitoring':
                return this.currentStatus.monitoring?.running === true;
            default:
                return false;
        }
    }

    isCurrentStep(stepId) {
        // Find first incomplete step
        for (const step of this.steps) {
            if (!this.isStepCompleted(step.id)) {
                return step.id === stepId;
            }
        }
        return false;
    }

    analyzeSituation() {
        const completedAll = this.steps.every(step => this.isStepCompleted(step.id));

        if (completedAll) {
            this.showCompletionMessage();
            return;
        }

        // Find next step
        const nextStep = this.steps.find(step => !this.isStepCompleted(step.id));
        if (nextStep) {
            this.suggestNextStep(nextStep);
        }
    }

    suggestNextStep(step) {
        const suggestions = {
            docker: {
                message: 'Docker n\'est pas encore install√©. C\'est la base de tout ! üê≥',
                description: 'Docker te permettra de d√©ployer tous les services facilement.',
                command: 'sudo bash common-scripts/02-docker-install-verify.sh',
                buttonText: 'üê≥ Installer Docker'
            },
            network: {
                message: 'Super ! Docker est pr√™t. Maintenant, configurons ton r√©seau. üì°',
                description: 'IP statique, hostname personnalis√©, DNS...',
                command: 'sudo bash common-scripts/set-static-ip.sh',
                buttonText: 'üì° Configurer r√©seau'
            },
            security: {
                message: 'R√©seau configur√© ‚úÖ Passons √† la s√©curit√© ! üîí',
                description: 'UFW (firewall), Fail2ban (protection brute force), SSH hardening',
                command: 'sudo bash common-scripts/01-system-hardening.sh',
                buttonText: 'üîí S√©curiser le Pi'
            },
            traefik: {
                message: 'Ton Pi est bien s√©curis√© ! Installons Traefik (reverse proxy). üåê',
                description: 'Traefik va g√©rer le routage et les certificats SSL automatiquement.',
                command: 'sudo bash common-scripts/03-traefik-setup.sh',
                buttonText: 'üåê Installer Traefik'
            },
            monitoring: {
                message: 'Presque fini ! Ajoutons du monitoring pour surveiller ton Pi. üìä',
                description: 'Prometheus + Grafana + Node Exporter pour des m√©triques en temps r√©el.',
                command: 'sudo bash 03-monitoring/prometheus-grafana/scripts/01-monitoring-deploy.sh',
                buttonText: 'üìä Installer Monitoring'
            }
        };

        const config = suggestions[step.id];
        if (config) {
            this.addMessage(config.message, 'assistant', {
                actions: [
                    { text: config.buttonText, command: config.command, primary: true },
                    { text: '‚è≠Ô∏è Passer cette √©tape', action: () => this.skipStep(step.id), primary: false },
                    { text: '‚ÑπÔ∏è En savoir plus', action: () => this.showStepInfo(step.id), primary: false }
                ],
                description: config.description
            });
        }
    }

    addMessage(text, type = 'assistant', options = {}) {
        const messagesContainer = document.getElementById('assistant-messages');
        if (!messagesContainer) return;

        this.messageCount++;
        const messageId = `msg-${this.messageCount}`;

        const messageDiv = document.createElement('div');
        messageDiv.className = `message ${type}-message`;
        messageDiv.id = messageId;

        const now = new Date();
        const timeStr = now.toLocaleTimeString('fr-FR', { hour: '2-digit', minute: '2-digit' });

        let html = '';

        if (type === 'assistant') {
            html += '<div class="message-avatar">ü§ñ</div>';
        }

        html += '<div class="message-content">';
        html += `<div class="message-text">${text}</div>`;

        if (options.description) {
            html += `<div class="message-description">${options.description}</div>`;
        }

        if (options.actions && options.actions.length > 0) {
            html += '<div class="message-actions">';
            options.actions.forEach((action, index) => {
                const btnClass = action.primary ? 'action-btn primary' : 'action-btn secondary';
                const dataAttr = action.command ? `data-command="${action.command}"` : '';
                html += `<button class="${btnClass}" data-msg-id="${messageId}" data-action-idx="${index}" ${dataAttr}>${action.text}</button>`;
            });
            html += '</div>';
        }

        html += '</div>';
        html += `<div class="message-time">${timeStr}</div>`;

        messageDiv.innerHTML = html;
        messagesContainer.appendChild(messageDiv);

        // Scroll to bottom
        messagesContainer.scrollTop = messagesContainer.scrollHeight;

        // Add event listeners to action buttons
        if (options.actions) {
            messageDiv.querySelectorAll('.action-btn').forEach((btn, index) => {
                btn.addEventListener('click', (e) => {
                    const command = btn.dataset.command;
                    const action = options.actions[index].action;

                    if (command) {
                        this.executeCommand(command, text);
                    } else if (action) {
                        action();
                    }

                    // Disable all buttons in this message after click
                    messageDiv.querySelectorAll('.action-btn').forEach(b => {
                        b.disabled = true;
                        b.style.opacity = '0.5';
                    });
                });
            });
        }
    }

    executeCommand(command, context) {
        // Add user message
        this.addMessage(`Lancement : ${command}`, 'user');

        // Execute in terminal
        terminalManager.executeCommand(command);

        // Add feedback message
        this.addMessage('‚è≥ Ex√©cution en cours... Surveille le terminal √† droite.', 'assistant');

        // Listen to execution end
        const checkInterval = setInterval(() => {
            if (!terminalManager.currentExecutionId) {
                clearInterval(checkInterval);
                setTimeout(() => {
                    this.load(); // Reload status after command
                }, 2000);
            }
        }, 1000);
    }

    skipStep(stepId) {
        this.addMessage(`√âtape "${stepId}" pass√©e. On continue !`, 'user');
        // Find next step
        const currentIndex = this.steps.findIndex(s => s.id === stepId);
        if (currentIndex >= 0 && currentIndex < this.steps.length - 1) {
            const nextStep = this.steps[currentIndex + 1];
            this.suggestNextStep(nextStep);
        } else {
            this.showCompletionMessage();
        }
    }

    showStepInfo(stepId) {
        const info = {
            docker: 'Docker est un syst√®me de conteneurisation qui permet de d√©ployer des applications de mani√®re isol√©e et reproductible.',
            network: 'Une IP statique garantit que ton Pi aura toujours la m√™me adresse r√©seau, facilitant l\'acc√®s distant.',
            security: 'UFW (Uncomplicated Firewall) prot√®ge ton Pi en bloquant les connexions non autoris√©es. Fail2ban bannit les IP qui tentent trop de connexions √©chou√©es.',
            traefik: 'Traefik est un reverse proxy moderne qui route le trafic vers tes services et g√®re les certificats SSL automatiquement.',
            monitoring: 'Prometheus collecte les m√©triques syst√®me, Grafana les visualise dans des dashboards interactifs.'
        };

        this.addMessage(info[stepId] || 'Pas d\'info disponible.', 'assistant');
    }

    showCompletionMessage() {
        this.addMessage('üéâ F√©licitations ! Ton Pi est compl√®tement configur√© !', 'assistant');
        this.addMessage(
            'Tu peux maintenant d√©ployer des services via l\'onglet "Scripts" ou consulter l\'√©tat de tes conteneurs dans "Docker".',
            'assistant',
            {
                actions: [
                    { text: 'üìú Voir les Scripts', action: () => window.tabsManager?.switchTab('scripts'), primary: true },
                    { text: 'üê≥ Voir Docker', action: () => window.tabsManager?.switchTab('docker'), primary: false }
                ]
            }
        );
    }
}

// Export singleton
const installationAssistant = new InstallationAssistant();
export default installationAssistant;
